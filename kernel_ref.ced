 ;
;
;******************************************************************************
;
;	Arquivo de Referência para o desenvolvimento do kernel.
;
;	Versão: 2022.2
;
;	Áreas de memória
;
;	0000 - 7FFF		_KERNEL
;					Área de Kernel para implementação dos alunos
;
;	0100 - 01FF		_VETTAB
;					Tabela com os vetores das funções do kernel
;					*** CUIDADO! Esse vetor está no meio da área de código ***
;
;	8000 - FF7F		_APP
;					Área onde será colocado o programa de aplicação.
;					Esse programa vai fazer o acesso aos periféricos e interrupções, através das funções do Kernel.
;
;	FF80 - FFBF 		_IOAREA16
;					Area de perifericos, acessada na base 16 bits
;
;	FFC0 - FFFF		_IOAREA08
;					Area de perifericos, acessada na base 8 bits
;					
;******************************************************************************


_KERNEL:	equ	h0000
_VETTAB:	equ	h0100
_RESET:		equ	_VETTAB+H0100
_APP:		equ	h8000
_IOAREA16:	equ	hFF80
_IOAREA08:	equ	hFFC0


;
;------------------------------------------------------------------------------
;	Área reservada para os periféricos
;------------------------------------------------------------------------------

; Acesso em 16 bits
		org		_IOAREA16
STACK:		daw		[31]
IVET:		dw		0			; Vetor de interrupção

; Acesso em 8 bits
		org		_IOAREA08
		dab		[23]
TIMDT:		db		0			; Registro de programação do timer
INTS:		db		0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:		db		0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:		db		0			; Status do teclado
TECDT:		db		0			; Dado do teclado
VISOR:		dab		[36]			; Portas de acesso ao visor

;	
;------------------------------------------------------------------------------
;	Ponto de entrada do RESET do processador
;------------------------------------------------------------------------------
		org		_KERNEL
		jmp		_RESET

;
;------------------------------------------------------------------------------
;	Area do kernel com os vetores das funções do kernel
;------------------------------------------------------------------------------
		org		_VETTAB
		
		dw		kbhit			; WORD	kbhit()
		dw		getchar			; BYTE	getchar()
		dw		putchar			; void	putchar(BYTE c)
		dw		putmsg			; void	putmsg(BYTE *msg)
		dw		timer			; void	timer(WORD tempo, WORD callback)
		dw		volume			; WORD	volume()

		
;	
;------------------------------------------------------------------------------
;	Código de RESET (BOOT) do processador/interrupção
;------------------------------------------------------------------------------
		org		_RESET
; 1) Desabilitar o sistema de interrupções
				
		AND		#H7C, INTE			; desabilitando as interrupções

; 2) Inicializar o stack pointer (SP = R6)

		MOV		#STACK, R6

; 3) Inicializar as variáveis internas usadas pelo sistema de interrupções e periféricos (IVET, INTE, etc.)

enderecoT:	DW		0
contador:	DB		0
temporizador:	DW		0
		
		CLR		INTS			
		MOV		#rotinaINT, IVET
		CLR		enderecoT		; limpando o endereco da função timer e o controle usado para contar os segundos


; 4) Inicializar as variáveis internas do kernel

CURSOR:		DB		0



; 5) Inicializar o teclado zerando o byte de estado (TECST, endereço 65498)
		
		CLR		TECST

; 6) Inicializar o timer

		CLR		 TIMDT			; setando o timer para 100 ms

; 7) Limpar o visor

		MOV		#VISOR,	R4
loopLimparVisor:		
		MOV		#H20, (R4)	 	; limpa (coloca um espaço em branco) na posição do cursor
		INC		R4
		CMP		#65533, R4
		BNE		loopLimparVisor
limparVolumeLoop:					; seta os 3  byte do volume
		MOV		#H30, (R4)
		INC		R4
		BNE		limparVolumeLoop		
		CLR		R4			; limpa o R4
		CLR		CURSOR
		CLR		R1
		CLR		R2
		CLR		R3
		CLR		R4
		CLR		R5

		
; 8) Habilitar interrupções

		OR		#H83, INTE		; habilitando interrupções de teclado e timer 1000 - 0011

; 9) Retornar para o programa de aplicação com um desvio para o endereço _APP da memória
		jmp		_APP


;
;------------------------------------------------------------------------------
; Rotina de Interrupção
;------------------------------------------------------------------------------
rotinaINT:
		MOV		R0, -(R6)		; Salva registradores 
		MOV		R1, -(R6)
		MOV		R2, -(R6)
		MOV		R3, -(R6)
		MOV		R4, -(R6)
		MOV		R5, -(R6)

timerINT:
		MOV		INTE, R1
		AND		#H1, R1			; verifica se a interrução do timer esta ativa
		BEQ		tecladoINT		; se for zero, vai as interrupções do timer estão desligadas, vai verificar o teclado
		MOV		INTS, R1		; Verifica se a interrupção é do timer
		AND		#1, R1
		BEQ		tecladoINT		; se for, continua, se não vai verificar se é do teclado	
		JSR		r7, tratamentoITimer	; trata a interrupção do timer
		AND		#HFE,	INTS		; desliga o bit de interrupção do timer
tecladoINT:
		MOV		INTE, R1		
		AND		#H2, R1
		BEQ		fimINT			; verifica se a interrupção do teclado esta ativo
		MOV		INTS,R1			; Verifica se a interrupção é do teclado
		AND		#2,R1
		BEQ		fimINT			; se nao for, vai para o fim da função interrupção
		JSR		r7,tratamentoITeclado	; trata a interrupção do teclado
		AND		#HFD, INTS		; desliga o bit de interrupção do teclado
fimINT:
		
		MOV		(r6)+,r5		; Retorna os registradores da pilha
		MOV		(r6)+,r4
		MOV		(r6)+,r3
		MOV		(r6)+,r2
		MOV		(r6)+,r1
		MOV		(r6)+,r0
		
		RTI	


tratamentoITimer:					; Tratamento de interrupção do timer
		CMP		enderecoT, #0		; compara se o endereço da função do timer é 0
		BEQ		fimTratamentoITimer	; se for, quer dizer que ainda nao lemos nenhum dado, logo, nao fazemos nada.
		SUB		#100, temporizador
		BGT		fimTratamentoITimer	; se nao for zero, continua normalmente
		MOV		enderecoT, R1
		JSR		R7, (R1)		; se for zero, chama a callback	
		CLR		enderecoT		; limpa o endereco da função da variavel.
		JMP		fimTratamentoITimer			
		
fimTratamentoITimer:
		RTS		R7
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; tratamento do teclado
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

tratamentoITeclado:					; Tratamento das interrupções de teclado
		
		MOV		TECDT,	R5		; Coloca o valor da tecla no R5 

		MOV		#65535, R3			; R3 tem o endereço do volume no visor

		CMP		R5, #H2B		; compara o dado com o sinal de +
		BNE		verificarDez		; se nao for igual, vai verificar o somar 10
testarNovamenteUm:
		CMP		R3, #65532		; nao deve aumentar mais de 9  o ultimo byte do volume
		BEQ		fimTratamentoITeclado	
		CMP		#57, (R3)		; comparar o ultimo byte do volume com 9
		BNE		somarMaisUm
		CMP		#57 , -2(R3)		; testa se os proximos bits do volume sao 99
		BEQ		testarSegundo
		JMP		seguirFluxo
testarSegundo:	
		CMP		#57, -1(R3)
		BEQ		fimTratamentoITeclado

seguirFluxo:
		MOV		#48, (R3)
		DEC		R3
		JMP		testarNovamenteUm
somarMaisUm:
		INC		(R3)			; aumentar volume em 1
		JMP		fimTratamentoITeclado

verificarDez:
		CMP		R5, #H2E		; compara dado com sinal de .
		BNE		verificarCem 		; se nao for igual, vai verificar o somar 100
		DEC		R3			; aumenta volume em 10
testarNovamenteDez:
		CMP		R3, #65532		; nao deve aumentar o mais de 9  o ultimo byte do volume
		BEQ		fimTratamentoITeclado
		CMP		#57, (R3)
		BNE		somarMaisDez
		CMP		#57, -1(R3)		; testa se o proximo bit do volume é 9
		BEQ		fimTratamentoITeclado
		MOV		#48, (R3)
		DEC		R3
		JMP		testarNovamenteDez
somarMaisDez:
		INC		(R3)
		JMP		fimTratamentoITeclado

verificarCem:
		CMP		R5, #H3E		; compara dado com sinal >
		BNE		diminuir		; se nao for igual, vai testar diminuir volume
		SUB		#2, R3			; aumenta volume em 100
		CMP		#57, (R3)
		BEQ		naoSomarCem		
		INC		(R3)
naoSomarCem:
		JMP		fimTratamentoITeclado
	

fimTratamentoITeclado:
		CLR		TECST			; limpa TECST
		RTS		R7
	

diminuir:
		
		CMP		R5, #H2D		; compara o dado com sinal de -
		BNE		verificarDez_		; se nao for igual, vai verificar o diminuir 10
		CMP		(R3), #48			; comparando o primeiro byte do volume com zero
		BNE		diminuirUm	
		DEC		R3
		CMP		(R3), #48
		BEQ		compararUltimo
		MOV		#57, 1(R3)
		DEC		(R3)
		JMP		fimTratamentoITeclado
compararUltimo:
		DEC		R3
		CMP		(R3), #48
		BEQ		fimTratamentoITeclado
		DEC		(R3)
		MOV		#57, 1(R3)
		MOV		#57, 2(R3)
		JMP		fimTratamentoITeclado_
		
diminuirUm:
		DEC		(R3)			; diminui o volume em 1
		CMP		1(R3), #0
		BEQ		fimTratamentoITeclado_
		MOV		#57, 1(R3)
		JMP		fimTratamentoITeclado_

verificarDez_:
		CMP		R5, #H2C		; compara dado com sinal de ,
		BNE		verificarCem_		; se nao for igual, vai verificar o diminuir 100
		DEC		R3
		CMP		#48, (R3)
		BNE		diminuirDez
		DEC		R3
		CMP		#48, (R3)
		BEQ		zerarVolume
		DEC		(R3)
		MOV		#57, 1(R3)
		JMP		fimTratamentoITeclado_
diminuirDez:	
		DEC		(R3)			; diminui volume em 10
		JMP		fimTratamentoITeclado_	

verificarCem_:	
		CMP		R5, #H3C		; compara dado com sinal <	
		BNE		fimTratamentoITeclado_	; se nao for igual, o caracter é ascii, colocar na tela
		SUB		#2, R3			; diminui o volume em 100
		CMP		(R3), #48
		BEQ		zerarVolume
		DEC		(R3)
		JMP		fimTratamentoITeclado_

zerarVolume:
		MOV		#VISOR, R3			
		ADD		#35, R3
		MOV		#48, (R3)
		DEC		R3
		MOV		#48, (R3)
		DEC		R3
		MOV		#48, (R3)	
		


fimTratamentoITeclado_:
		CLR		TECST			; limpa TECST
		RTS		R7


;		
;------------------------------------------------------------------------------
; WORD	kbhit()
;------------------------------------------------------------------------------
kbhit:

		CMP		TECST, #H80		; se TECST for igual a H80, então há tecla para ser lida,
		BEQ		haTecla			; se TECST for H80, a função deve retornar 0 (retorno pelo R0)
		MOV		#1, R0			; se TECST for diferente de H80, a função deve retornar 1 (retorno pelo R0)
		JMP		fimkbhit
haTecla:
		CLR		R0
fimkbhit:

		RTS		R7
	
;		
;------------------------------------------------------------------------------
; BYTE	getchar()
;------------------------------------------------------------------------------
getchar:
		AND		#HFD, INTE		; desliga a interrupção por teclado
getcharloop:
		JSR		R7, kbhit		; chama a função kbhit para ver se há tecla
		CMP 		R0, #0			; testa se R0 (retorno de kbhit) é zero
		BNE		getcharloop		; se não for, volta para 'getchar' ate R0 ser zero

		MOV		TECDT, R0		; caso R0 for zero, coloca o dado que esta em TECDT e R0
		CLR		TECST			; limpa TECST pois o dado ja foi lido
		OR		#2, INTE		; liga a interrupção por teclado
		
		RTS	 	R7			

;	
;------------------------------------------------------------------------------
; void	putchar(BYTE c)
;------------------------------------------------------------------------------
putchar:						; tem como parametro de entra o BYTE c no R5
		MOV		#VISOR,	R4
		ADD		CURSOR, R4

		CMP		R5, #H20		; compara o dado com H20 (minimo valor aceito)  = R5 - h20
		BLT		naoASCII		; se o resultado for negativo, R5 é menor que o menor dado possivel, pula para outra verificação
		CMP		R5, #H7A		; compara o dado com H7B (maior valor aceito + 1)  = H7B - R5
		BGT		naoASCII		; se o valor não for negativo, R5 é maior que o maior dado possivel, pula para outra verificação
		

		CMP		#H3c, R5		; compara com <
		BEQ		fimPutChar_
		CMP		#H3e, R5		; compara com >
		BEQ		fimPutChar_
		CMP		#H2c, R5		; compara com ,
		BEQ		fimPutChar_
		CMP		#H2e, R5		; compara com .
		BEQ		fimPutChar_

		JMP		ascii			; pula para caracter ascii
fimPutChar_:

		RTS		R7

ascii:
		CMP		#65530, R4		; compara se o cursor ja saiu do limite
		BEQ		fimPutChar		; vai para as outras verificações
		MOV		R5, (R4)	  	; se o dado estiver no limite estipulado, coloca ele no endereço do cursor
		INC		CURSOR			; encrementa o cursor
		INC		R4
		JMP		fimPutChar		; acaba a função
naoASCII:
		CMP		R5, #H08  		; compara se R5 é o backspace
		BEQ		backSpace		; se nao for, pula para a proxima comparação	

		CMP		R5, #H0D 		; ve se o dado é Carriage return (mover cursor para inicio do visor)
		BEQ		moverCursorInicio	; se não for, pula para a proxima comparação

		CMP		R5, #H0A		; ve se o dado é line feed 	(limpar vizor)
		BEQ		limparCaracteres		; se não for, o dado não é aceito, vai para o fim da função sem fazer nada
		
		JMP		fimPutChar

backSpace:
		CMP		R4, #65501		; ve se o cursor ja esta no max da esquerda
		BMI		fimPutChar		; se sim, vai direto para o fim da função
		DEC		CURSOR			; se não, decrementa um do CURSOR e, depois, vai para o fim da função
		DEC		R4
;;;;;;;		MOV		#H20, (R4)		; limpa o visor no cursor atual
		JMP		fimPutChar


moverCursorInicio:
		MOV		#0, cursor		; se for, retorna o CURSOR para o endereço inicial do VISOR				; 
		JMP		fimPutChar		; vai para o fim da função

limparCaracteres:
		MOV		#VISOR, R4
loopVisor:	
		MOV		#32, (R4) 		; limpa (coloca um espaço em branco) na posição do cursor
		INC 		R4			; incrementa o cursor para o proximo espaço a ser limpado
		CMP		R4, #HFFFD
		BNE		loopVisor		; faz essa chamada ate o contador ser zero
		MOV		#0, cursor			; volta o cursor para o inicio do visor

fimPutChar:

		RTS		R7


;		
;------------------------------------------------------------------------------
; void	putmsg(BYTE *msg)
;------------------------------------------------------------------------------
putmsg:							; R5 tera o endereço de menoria onde inicia a string
		AND		#HFD, INTE		; desabilitar interrupções na escrita
		MOV		R5, R2	
		DEC		R2			; diminuo um do end da string pois 
colocandoMSG:
		MOV		(R2), R5		; move o dado do endereço do vetor da string para o registrador R5 (sera usado como parametro em putchar)
		INC		R2
		AND		#HFF, R5
		CMP		R5 , #0			; compara se o valor da string é zero
		BEQ		fimPutMsg		; se for a string acabou, fim da subrotina
		JSR		R7, putchar		; chama a função putchar com o dado da string no R5		
		JMP		colocandoMSG		; continua o laço até que o visor esteja cheio ou acabe a string
	
fimPutMsg:
		OR		#2, INTE		; habilita as interrupções de escrita novamente
		RTS		R7

;		
;------------------------------------------------------------------------------
; void	timer(WORD tempo, WORD callback)
;------------------------------------------------------------------------------
timer:						; R5 - tempo do timer
						; R4 - endereço da callback
		MOV		R5, temporizador	; Movendo o tempo do timer para a variavel
		MOV		R4, enderecoT		; movendo o endereço da callback para a variavel, para chamar mais tarde
		
		RTS		r7
				
;		
;------------------------------------------------------------------------------
; WORD	volume()
;------------------------------------------------------------------------------
volume:							; volta o volume no R0
		MOV		#VISOR, R3			
		ADD		#35, R3			; coloca o R3 como cursor do volume no primeiro byte
		
		CLR		contador
		CLR		R0

		CMP		(R3), #48		; ver se é igual a zero		
		BEQ		segundoDigito
		MOV		(R3), R0
		SUB		#48,  R0		; deixar o numero em decimal novamente, nao em ascii e colocar no R0
segundoDigito:
		DEC		R3
		CMP		(R3), #48		; ver se é igual a zero
		BEQ		terceiroDigito
		MOV		(R3), R2
		SUB		#48, R2			; deixar o numero em decimal novamente, nao em ascii
		MOV		#10, contador	
somar2D:
		ADD		R2, R0			; adicionar 10 vezes o segundo digito em R0
		DEC		contador		
		BNE		somar2D

terceiroDigito:
		DEC		R3
		CMP		(R3), #48		; ver se é igual a zero
		BEQ		finalVolume
		MOV		(R3), R2
		SUB		#48,  R2		; deixar o numero em decimal novamente, nao em ascii
		MOV		#100, contador		; adicionar 100 vezes o terceiro digito
somar3D:					
		ADD		R2, R0	
		DEC		contador
		BNE		somar3D
finalVolume:	
		CLR		contador		; limpamos o contador e retornamos
		RTS		R7
